mutable struct PlanktonInput
    temp::AbstractArray{Float64,4}      # temperature
    PARF::AbstractArray{Float64,3}      # PARF
    vels::NamedTuple                    # velocity fields for nutrients and individuals
    ΔT_vel::Int                         # time step of velocities provided
    ΔT_PAR::Int                         # time step of surface PAR provided
    ΔT_temp::Int                        # time step of temperature provided
end

mutable struct PlanktonSimulation
    model::PlanktonModel                       # Model object
    input::PlanktonInput                       # model input, temp, PAR, and velocities
    diags::Union{PlanktonDiagnostics,Nothing}  # diagnostics
    ΔT::Int64                                  # model time step
    iterations::Int64                          # run the simulation for this number of iterations
    res_dir::Union{String,Nothing}             # directory to store results
    save_individuals::Union{Int64,Nothing}     # save individuals every `Int64` time steps
end

"""
    PlanktonSimulation(model; ΔT, iterations,
                       PARF = default_PARF(model.grid),
                       temp = default_temperature(model.grid),
                       diags = nothing,
                       vels = (;),
                       ΔT_vel = ΔT,
                       ΔT_PAR::Int64 = 3600,
                       ΔT_temp::Int64 = 3600,
                       res_dir = nothing
                       save_individuals = nothing,
                       )
Generate a `PlanktonSimulation` data structure.

Keyword Arguments (Required)
============================
- `ΔT` : time step in second.
- `iterations` : run the simulation for this number of iterations.

Keyword Arguments (Optional)
============================
- `PARF` : External forcings of surface PAR. Hourly PAR of a single day is provided by default.
- `temp` : External forcings of temperature. Hourly data of a single day is provided by default.
- `diags` : Diagnostics of the simulation generated by `PlanktonDiagnostics`.
- `vels` : The velocity fields for nutrient fields and individuals. `nothing` means no velocities
                     will be applied in the simulation. Otherwise, `vels` mush be a `NamedTuple` containing
                     all `u`, `v`, and `w`. Each of `u`, `v`, and `w` must be an 4D-`Array` of 
                     `(Nx, Ny, Nz, nΔT)` elements, excluding halo points. `N+1` is required for bounded direction.
- `ΔT_vel` : time step of velocities provided externally (in seconds).
- `ΔT_PAR` : time step of surface PAR provided externally (in seconds).
- `ΔT_temp` : time step of temperature provided externally (in seconds).
- `res_dir` : Create a directory to store results, `nothing` by default.
- `save_individuals` : save individuals every `Int64` time steps, do not save individuals if `Nothing`.
"""
function PlanktonSimulation(model::PlanktonModel; ΔT::Int64, iterations::Int64,
                            PARF = default_PARF(model.grid, ΔT, iterations),
                            temp = default_temperature(model.grid, ΔT, iterations),
                            diags = nothing,
                            vels = (;),
                            ΔT_vel::Int64 = ΔT,
                            ΔT_PAR::Int64 = 3600,
                            ΔT_temp::Int64 = 3600,
                            res_dir = nothing,
                            save_individuals = nothing,
                            )

    if vels ≠ (;)
        if validate_velocity(vels, model.grid)
            vel_copy!(model.timestepper.vel₀, vels.u[:,:,:,1], vels.v[:,:,:,1], vels.w[:,:,:,1], model.grid)
        end

        @assert ΔT_vel % ΔT == 0.0

        if size(vels.u)[4] < floor(Int,iterations*ΔT/ΔT_vel)
            throw(ArgumentError("Velocities provided cannot cover the time period of (iterations+1)*ΔT ($(iterations*ΔT) seconds) with ΔT_vel = $(ΔT_vel)."))
        end
    end

    if size(PARF)[3] < floor(Int,iterations*ΔT/ΔT_PAR)
        throw(ArgumentError("Surface PAR provided cannot cover the time period of (iterations+1)*ΔT ($(iterations*ΔT) seconds) with ΔT_PAR = $(ΔT_PAR)."))
    end

    if size(temp)[4] < floor(Int,iterations*ΔT/ΔT_temp)
        throw(ArgumentError("Temperature provided cannot cover the time period of (iterations+1)*ΔT ($(iterations*ΔT) seconds) with ΔT_temp = $(ΔT_temp)."))
    end

    if diags ≠ nothing
        if res_dir == nothing
            throw(ArgumentError("Need to specify result directory to save diagnostics"))
        end
    end

    input = PlanktonInput(temp, PARF, vels, ΔT_vel, ΔT_PAR, ΔT_temp)

    validate_bcs(model.nutrients, model.grid, iterations)

    sim = PlanktonSimulation(model, input, diags, ΔT, iterations, res_dir, save_individuals)

    return sim
end

function save_inds_string(sim::PlanktonSimulation)
    save_inds = sim.save_individuals == nothing ? false : true
    if save_inds
        return "save individuals every $(sim.save_individuals) time steps"
    else
        return "save individuals: $(save_inds)"
    end
end
function vels_string(sim::PlanktonSimulation)
    if sim.input.vels == (;)
        return "no velocity provided"
    else
        return "velocity provided, one time step of velocity covers $(sim.input.ΔT_vel/sim.ΔT) time steps of simulation"
    end
end

function show(io::IO, sim::PlanktonSimulation)
    save_diags = sim.diags == nothing ? false : true
    print(io, "ΔT: $(sim.ΔT)s\n",
            "model time: $(sim.model.t)s\n",
            "simulation stops after: $(sim.iterations) iterations\n",
            "results saved at $(sim.res_dir)\n",
            "save diags: $(save_diags)\n",
            "$(save_inds_string(sim))\n",
            "$(vels_string(sim))\n")

end


"""
    update!(sim::PlanktonSimulaiton)
update the `PlanktonSimulaiton` for `sim.iterations` time steps.
"""
function update!(sim::PlanktonSimulation)
    if sim.input.vels ≠ (;)
        for t in 1:sim.iterations
            t_vel = Int(sim.model.t÷sim.input.ΔT_vel)+1 # starting from 1
            vel_copy!(sim.model.timestepper.vel₁, sim.input.vels.u[:,:,:,t_vel],
                      sim.input.vels.v[:,:,:,t_vel], sim.input.vels.w[:,:,:,t_vel], sim.model.grid)

            # tc = sim.model.t % 86400 ÷ sim.ΔT + 1 # time of day in ΔT as Int index for temp and PAR
            t_par = Int(sim.model.t÷sim.input.ΔT_PAR)+1 # starting from 1
            copyto!(sim.model.timestepper.PARF, sim.input.PARF[:,:,t_par])

            t_temp = Int(sim.model.t÷sim.input.ΔT_temp)+1 # starting from 1
            copy_interior!(sim.model.timestepper.temp, sim.input.temp[:,:,:,t_temp], sim.model.grid)

            TimeStep!(sim.model, sim.ΔT, sim.diags, sim.res_dir)

            if sim.diags ≠ nothing
                if sim.model.t % (sim.diags.frequency*sim.ΔT) == 0.0
                    write_diags_to_jld2(sim.diags, sim.res_dir, sim.model.t, sim.diags.frequency, sim.model.grid)
                end
            end

            if sim.save_individuals ≠ nothing
                if sim.model.t % (sim.save_individuals*sim.ΔT) == 0.0
                    write_individuals_to_jld2(sim.model.individuals.phytos, sim.res_dir, sim.model.t,
                                                atts=(:x, :y, :z, :Sz))
                end
            end
        end
    else
        for t in 1:sim.iterations
            t_par = Int(sim.model.t÷sim.input.ΔT_PAR)+1 # starting from 1
            copyto!(sim.model.timestepper.PARF, sim.input.PARF[:,:,t_par])

            t_temp = Int(sim.model.t÷sim.input.ΔT_temp)+1 # starting from 1
            copy_interior!(sim.model.timestepper.temp, sim.input.temp[:,:,:,t_temp], sim.model.grid)

            TimeStep!(sim.model, sim.ΔT, sim.diags, sim.res_dir)

            if sim.diags ≠ nothing
                if sim.model.t % (sim.diags.frequency*sim.ΔT) == 0.0
                    write_diags_to_jld2(sim.diags, sim.res_dir, sim.model.t, sim.diags.frequency, sim.model.grid)
                end
            end
            if sim.save_individuals ≠ nothing
                if sim.model.t % (sim.save_individuals*sim.ΔT) == 0.0
                    write_individuals_to_jld2(sim.model.individuals.phytos, sim.res_dir, sim.model.t,
                                                atts=(:x, :y, :z, :Sz))
                end
            end
        end
    end
end

function validate_velocity(vels, g::AbstractGrid{TX, TY, TZ}) where {TX, TY, TZ}
    u_size = (g.Nx, g.Ny, g.Nz)
    v_size = (g.Nx, g.Ny, g.Nz)
    w_size = (g.Nx, g.Ny, g.Nz)
    validation = true

    if isa(TX(), Bounded)
        u_size = (g.Nx+1, g.Ny, g.Nz)
    end

    if isa(TY(), Bounded)
        v_size = (g.Nx, g.Ny+1, g.Nz)
    end

    if isa(TZ(), Bounded)
        w_size = (g.Nx, g.Ny, g.Nz+1)
    end

    if size(vels.u)[1:3] ≠ u_size
        validation = false
        throw(ArgumentError("Dimension mismatch: the size of u must be $(u_size), for $(TX) topology."))
    end

    if size(vels.v)[1:3] ≠ v_size
        validation = false
        throw(ArgumentError("Dimension mismatch: the size of v must be $(v_size), for $(TY) topology."))
    end

    if size(vels.w)[1:3] ≠ w_size
        validation = false
        throw(ArgumentError("Dimension mismatch: the size of w must be $(w_size), for $(TZ) topology."))
    end

    return validation
end

