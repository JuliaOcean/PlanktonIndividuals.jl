mutable struct PlanktonInput
    temp::AbstractArray{AbstractFloat,4}      # temperature
    PARF::AbstractArray{AbstractFloat,3}      # PARF
    vels::NamedTuple                          # velocity fields
    ΔT_vel::AbstractFloat                     # time step of velocities provided
    ΔT_PAR::AbstractFloat                     # time step of surface PAR provided
    ΔT_temp::AbstractFloat                    # time step of temperature provided
end

mutable struct PlanktonSimulation
    model::PlanktonModel                       # Model object
    input::PlanktonInput                       # model input, temp, PAR, and velocities
    diags::Union{PlanktonDiagnostics,Nothing}  # diagnostics
    ΔT::AbstractFloat                          # model time step
    iterations::Int                            # run the simulation for this number of iterations
    output_writer::Union{PlanktonOutputWriter,Nothing} # Output writer
end

"""
    PlanktonSimulation(model; ΔT, iterations,
                       PARF = default_PARF(model.grid),
                       temp = default_temperature(model.grid),
                       diags = nothing,
                       vels = (;),
                       ΔT_vel = ΔT,
                       ΔT_PAR::AbstractFloat = 3600.0f0,
                       ΔT_temp::AbstractFloat = 3600.0f0,
                       output_writer = nothing,
                       )
Generate a `PlanktonSimulation` data structure.

Keyword Arguments (Required)
============================
- `ΔT` : time step in second.
- `iterations` : run the simulation for this number of iterations.

Keyword Arguments (Optional)
============================
- `PARF` : External forcings of surface PAR. Hourly PAR of a single day is provided by default.
- `temp` : External forcings of temperature. Hourly data of a single day is provided by default.
- `diags` : Diagnostics of the simulation generated by `PlanktonDiagnostics`.
- `vels` : The velocity fields for tracer fields and individuals. `nothing` means no velocities
                     will be applied in the simulation. Otherwise, `vels` mush be a `NamedTuple` containing
                     all `u`, `v`, and `w`. Each of `u`, `v`, and `w` must be an 4D-`Array` of 
                     `(Nx, Ny, Nz, nΔT)` elements, excluding halo points. `N+1` is required for bounded direction.
- `ΔT_vel` : time step of velocities provided externally (in seconds).
- `ΔT_PAR` : time step of surface PAR provided externally (in seconds).
- `ΔT_temp` : time step of temperature provided externally (in seconds).
- `output_writer` : Output writer of the simulation generated by `PlanktonOutputWriter`.
"""
function PlanktonSimulation(model::PlanktonModel; ΔT::AbstractFloat, iterations::Int,
                            PARF = nothing,
                            temp = nothing,
                            diags = nothing,
                            vels = (;),
                            ΔT_vel::AbstractFloat = ΔT,
                            ΔT_PAR::AbstractFloat = 3600.0f0,
                            ΔT_temp::AbstractFloat = 3600.0f0,
                            output_writer = nothing
                            )

    FT = model.FT

    if vels ≠ (;)
        vels_ft = (u = FT.(vels.u), v = FT.(vels.v), w = FT.(vels.w))
    else
        vels_ft = (;)
    end

    if isa(PARF, Nothing)
        PARF = default_PARF(model.grid, ΔT, iterations)
    end

    if isa(temp, Nothing)
        grid = replace_grid_storage(CPU(), model.grid)
        temp = default_temperature(grid, ΔT, iterations)
    end

    input = PlanktonInput(FT.(temp), FT.(PARF), vels_ft, FT(ΔT_vel), FT(ΔT_PAR), FT(ΔT_temp))

    validate_bcs(model.tracers, model.grid, iterations)

    if isnothing(diags)
        diags = PlanktonDiagnostics(model)
    end

    sim = PlanktonSimulation(model, input, diags, FT(ΔT), iterations, output_writer)

    validate_velocity(sim, model.grid)
    validate_PARF(sim, model.grid)
    validate_temp(sim, model.grid)

    return sim
end

function vels_string(sim::PlanktonSimulation)
    if sim.input.vels == (;)
        return "no velocity provided"
    else
        return "velocity provided, one time step of velocity covers $(sim.input.ΔT_vel/sim.ΔT) time steps of simulation"
    end
end

function show(io::IO, sim::PlanktonSimulation)
    print(io, "PlanktonSimulation:\n",
              "├── ΔT: $(sim.ΔT)s\n",
              "├── model time: $(sim.model.t)s\n",
              "├── simulation stops after: $(sim.iterations) iterations\n",
              "├── $(vels_string(sim))\n",
              "├── diagnostics: $(short_show(sim.diags))\n",
              "└── output writer: $(short_show(sim.output_writer))"
              )

end


function short_show(diags::PlanktonDiagnostics)
    return string("\n", "│   ├── diagnostics of tracers: $(keys(diags.tracer))\n", 
                        "│   ├── diagnostics of phytoplankton: $(keys(diags.phytoplankton.sp1))\n",
                        "│   ├── diagnostics of abiotic particles: $(keys(diags.abiotic_particle.sp1))\n",
                        "│   └── save averaged diagnostics every $(diags.iteration_interval) timesteps")
end
function short_show(writer::PlanktonOutputWriter)
    return string("\n", "    ├── files are saved at $(writer.filepath)\n", 
                        "    └── Maximum file size: $(humanize_filesize(writer.max_filesize))")
end
function short_show(nothing::Nothing)
    return string("nothing")
end
