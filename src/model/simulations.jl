mutable struct PlanktonInput
    temp::AbstractArray{Float64,4}      # temperature
    PARF::AbstractArray{Float64,3}      # PARF
    vels::NamedTuple                    # velocity fields for nutrients and individuals
end

mutable struct PlanktonSimulation
    model::PlanktonModel                       # Model object
    input::PlanktonInput                       # model input, temp, PAR, and velocities
    diags::Union{PlanktonDiagnostics,Nothing}  # diagnostics
    ΔT::Int64                                  # model time step
    nΔT::Int64                                 # number of time steps to run in the simulation
    res_dir::Union{String,Nothing}             # directory to store results
    save_individuals::Bool
    vel_reuse::Bool
end

"""
    PlanktonSimulation(model; ΔT, nΔT,
                       PARF_path = PlanktonIndividuals.default_PAR,
                       temp_path = PlanktonIndividuals.default_temperature,
                       diags = nothing,
                       vels = (;),
                       res_dir = nothing
                       save_individuals = false,
                       vel_reuse = false
                       )
Generate a `PlanktonSimulation` data structure.

Keyword Arguments (Required)
============================
- `ΔT` : time step in second.
- `nΔT` : number of time steps.

Keyword Arguments (Optional)
============================
- `PARF_path` and `temp_path` : External forcings of PAR and temperature. Hourly data of a single day is required (25 data points in total).
- `diags` : Diagnostics of the simulation generated by `PlanktonDiagnostics`.
- `res_dir` : Create a directory to store results, `nothing` by default.
- `vels` : The velocity fields for nutrient fields and individuals. `nothing` means no velocities
                     will be applied in the simulation. Otherwise, `vels` mush be a `NamedTuple` containing
                     all `u`, `v`, and `w`. Each of `u`, `v`, and `w` must be an 4D-`Array` of 
                     `(Nx, Ny, Nz+1, nΔT+1)` elements, excluding halo points, but bounded in `z` direction.
"""
function PlanktonSimulation(model::PlanktonModel; ΔT::Int64, nΔT::Int64,
                            PARF_path = PlanktonIndividuals.default_PAR,
                            temp_path = PlanktonIndividuals.default_temperature,
                            diags = nothing,
                            vels = (;),
                            res_dir = nothing,
                            save_individuals = false,
                            vel_reuse = false
                            )

    if vels ≠ (;)
        grid_size = (model.grid.Nx, model.grid.Ny, model.grid.Nz)
        grid_size_w = (model.grid.Nx, model.grid.Ny, model.grid.Nz+1)
        if size(vels.u)[1:3] == size(vels.v)[1:3] == grid_size
            if size(vels.w)[1:3] == grid_size_w
                vel_copy!(model.timestepper.vel₀, vels.u[:,:,:,1],
                        vels.v[:,:,:,1], vels.w[:,:,:,1], model.grid)
            else
                throw(ArgumentError("Dimension mismatch: the size of w must be $(grid_size_w), Nz+1 layers for bounded direction."))
            end
        else
            throw(ArgumentError("Dimension mismatch: the size of u and v must be $(grid_size)."))
        end

        if size(vels.u)[4] < nΔT
            throw(ArgumentError("Velocities provided not enough for $(nΔT) time steps."))
        end
    end

    if diags ≠ nothing
        if res_dir == nothing
            throw(ArgumentError("Need to specify result directory to save diagnostics"))
        end
    end

    temp = read_temp_input(ΔT, model.grid, path = temp_path)
    PARF = read_IR_input(ΔT, model.grid, path = PARF_path)
    input = PlanktonInput(temp, PARF, vels)

    validate_bcs(model.nutrients, model.grid, nΔT)

    sim = PlanktonSimulation(model, input, diags, ΔT, nΔT, res_dir, save_individuals, vel_reuse)

    return sim
end

import Base: show

function show(io::IO, sim::PlanktonSimulation)
    save_diags = sim.diags == nothing ? false : true
    print(io, "ΔT: $(sim.ΔT)s\n",
              "model time: $(sim.model.t)s\n",
              "number of time steps: $(sim.nΔT)\n",
              "results saved at $(sim.res_dir)\n",
              "save diags: $(save_diags)\n",
              "save individuals: $(sim.save_individuals)\n",
              "reuse velocity fields: $(sim.vel_reuse)\n")
end


"""
    update!(sim::PlanktonSimulaiton)
update the `PlanktonSimulaiton` for `sim.nΔT` time steps.
"""
function update!(sim::PlanktonSimulation)
    if sim.input.vels ≠ (;)
        if sim.vel_reuse
            ti = 1
            te = sim.nΔT
        else
            ti = sim.model.t÷sim.ΔT + 1
            te = sim.model.t÷sim.ΔT + sim.nΔT
        end
        for t in ti:te
            tc = sim.model.t % 86400 ÷ sim.ΔT + 1 # time of day in ΔT as Int index for temp and PAR
            vel_copy!(sim.model.timestepper.vel₁, sim.input.vels.u[:,:,:,t],
                      sim.input.vels.v[:,:,:,t], sim.input.vels.w[:,:,:,t], sim.model.grid)
            copyto!(sim.model.timestepper.PARF, sim.input.PARF[:,:,tc])
            copy_interior!(sim.model.timestepper.temp, sim.input.temp[:,:,:,tc], sim.model.grid)

            TimeStep!(sim.model, sim.ΔT, sim.diags, sim.res_dir)

            if sim.diags ≠ nothing
                if sim.model.t % (sim.diags.frequency*sim.ΔT) == 0.0
                    write_diags_to_jld2(sim.diags, sim.res_dir, sim.model.t, sim.diags.frequency)
                end
                if sim.save_individuals
                    write_individuals_to_jld2(sim.model.individuals.phytos, sim.res_dir, sim.model.t,
                                              atts=(:x, :y, :z, :Sz))
                end
            end
        end
    else
        for t in 1:sim.nΔT
            tc = sim.model.t % 86400 ÷ sim.ΔT + 1 # time of day in ΔT as Int index for temp and PAR
            copyto!(sim.model.timestepper.PARF, sim.input.PARF[:,:,tc])
            copy_interior!(sim.model.timestepper.temp, sim.input.temp[:,:,:,tc], sim.model.grid)

            TimeStep!(sim.model, sim.ΔT, sim.diags, sim.res_dir)

            if sim.diags ≠ nothing
                if sim.model.t % (sim.diags.frequency*sim.ΔT) == 0.0
                    write_diags_to_jld2(sim.diags, sim.res_dir, sim.model.t, sim.diags.frequency)
                end
                if sim.save_individuals
                    write_individuals_to_jld2(sim.model.individuals.phytos, sim.res_dir, sim.model.t,
                                              atts=(:x, :y, :z, :Sz))
                end
            end
        end
    end
end
