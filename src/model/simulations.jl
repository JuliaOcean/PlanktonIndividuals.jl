mutable struct PlanktonInput
    temp::AbstractArray{Float64,4}      # temperature
    PARF::AbstractArray{Float64,3}      # PARF
    vels::NamedTuple                    # velocity fields for nutrients and individuals
end

mutable struct PlanktonSimulation
    model::PlanktonModel                       # Model object
    input::PlanktonInput                       # model input, temp, PAR, and velocities
    diags::Union{PlanktonDiagnostics,Nothing}  # diagnostics
    ΔT::Int64                                  # model time step
    nΔT::Int64                                 # number of time steps to run in the simulation
    res_dir::Union{String,Nothing}             # directory to store results
    save_individuals::Union{Int64,Nothing}     # save individuals every `Int64` time steps
    vel_reuse::Bool
end

"""
    PlanktonSimulation(model; ΔT, nΔT,
                       PARF_path = PlanktonIndividuals.default_PAR,
                       temp_path = PlanktonIndividuals.default_temperature,
                       diags = nothing,
                       vels = (;),
                       res_dir = nothing
                       save_individuals = nothing,
                       vel_reuse = false
                       )
Generate a `PlanktonSimulation` data structure.

Keyword Arguments (Required)
============================
- `ΔT` : time step in second.
- `nΔT` : number of time steps.

Keyword Arguments (Optional)
============================
- `PARF_path` and `temp_path` : External forcings of PAR and temperature. Hourly data of a single day is required (25 data points in total).
- `diags` : Diagnostics of the simulation generated by `PlanktonDiagnostics`.
- `res_dir` : Create a directory to store results, `nothing` by default.
- `vels` : The velocity fields for nutrient fields and individuals. `nothing` means no velocities
                     will be applied in the simulation. Otherwise, `vels` mush be a `NamedTuple` containing
                     all `u`, `v`, and `w`. Each of `u`, `v`, and `w` must be an 4D-`Array` of 
                     `(Nx, Ny, Nz, nΔT+1)` elements, excluding halo points. `N+1` is required for bounded direction.
- `save_individuals` : save individuals every `Int64` time steps, do not save individuals if `Nothing`.
- `vel_reuse` : reuse the provided velocity fields if `true`.
"""
function PlanktonSimulation(model::PlanktonModel; ΔT::Int64, nΔT::Int64,
                            PARF_path = PlanktonIndividuals.default_PAR,
                            temp_path = PlanktonIndividuals.default_temperature,
                            diags = nothing,
                            vels = (;),
                            res_dir = nothing,
                            save_individuals = nothing,
                            vel_reuse = false
                            )

    if vels ≠ (;)
        if validate_velocity(vels, model.grid)
            vel_copy!(model.timestepper.vel₀, vels.u[:,:,:,1], vels.v[:,:,:,1], vels.w[:,:,:,1], model.grid)
        end

        if size(vels.u)[4] < nΔT
            throw(ArgumentError("Velocities provided not enough for $(nΔT) time steps."))
        end
    end

    if diags ≠ nothing
        if res_dir == nothing
            throw(ArgumentError("Need to specify result directory to save diagnostics"))
        end
    end

    temp = read_temp_input(ΔT, model.grid, path = temp_path)
    PARF = read_IR_input(ΔT, model.grid, path = PARF_path)
    input = PlanktonInput(temp, PARF, vels)

    validate_bcs(model.nutrients, model.grid, nΔT)

    sim = PlanktonSimulation(model, input, diags, ΔT, nΔT, res_dir, save_individuals, vel_reuse)

    return sim
end

import Base: show

function show(io::IO, sim::PlanktonSimulation)
    save_diags = sim.diags == nothing ? false : true
    save_inds = sim.save_individuals == nothing ? false : true
    if save_inds
        print(io, "ΔT: $(sim.ΔT)s\n",
                "model time: $(sim.model.t)s\n",
                "number of time steps: $(sim.nΔT)\n",
                "results saved at $(sim.res_dir)\n",
                "save diags: $(save_diags)\n",
                "save individuals every $(sim.save_individuals) time steps\n",
                "reuse velocity fields: $(sim.vel_reuse)\n")
    else
        print(io, "ΔT: $(sim.ΔT)s\n",
                "model time: $(sim.model.t)s\n",
                "number of time steps: $(sim.nΔT)\n",
                "results saved at $(sim.res_dir)\n",
                "save diags: $(save_diags)\n",
                "save individuals: $(save_inds)\n",
                "reuse velocity fields: $(sim.vel_reuse)\n")
    end

end


"""
    update!(sim::PlanktonSimulaiton)
update the `PlanktonSimulaiton` for `sim.nΔT` time steps.
"""
function update!(sim::PlanktonSimulation)
    if sim.input.vels ≠ (;)
        if sim.vel_reuse
            ti = 1
            te = sim.nΔT
        else
            ti = sim.model.t÷sim.ΔT + 1
            te = sim.model.t÷sim.ΔT + sim.nΔT
        end
        for t in ti:te
            tc = sim.model.t % 86400 ÷ sim.ΔT + 1 # time of day in ΔT as Int index for temp and PAR
            vel_copy!(sim.model.timestepper.vel₁, sim.input.vels.u[:,:,:,t],
                      sim.input.vels.v[:,:,:,t], sim.input.vels.w[:,:,:,t], sim.model.grid)
            copyto!(sim.model.timestepper.PARF, sim.input.PARF[:,:,tc])
            copy_interior!(sim.model.timestepper.temp, sim.input.temp[:,:,:,tc], sim.model.grid)

            TimeStep!(sim.model, sim.ΔT, sim.diags, sim.res_dir)

            if sim.diags ≠ nothing
                if sim.model.t % (sim.diags.frequency*sim.ΔT) == 0.0
                    write_diags_to_jld2(sim.diags, sim.res_dir, sim.model.t, sim.diags.frequency, sim.model.grid)
                end
            end

            if sim.save_individuals ≠ nothing
                if sim.model.t % (sim.save_individuals*sim.ΔT) == 0.0
                    write_individuals_to_jld2(sim.model.individuals.phytos, sim.res_dir, sim.model.t,
                                                atts=(:x, :y, :z, :Sz))
                end
            end
        end
    else
        for t in 1:sim.nΔT
            tc = sim.model.t % 86400 ÷ sim.ΔT + 1 # time of day in ΔT as Int index for temp and PAR
            copyto!(sim.model.timestepper.PARF, sim.input.PARF[:,:,tc])
            copy_interior!(sim.model.timestepper.temp, sim.input.temp[:,:,:,tc], sim.model.grid)

            TimeStep!(sim.model, sim.ΔT, sim.diags, sim.res_dir)

            if sim.diags ≠ nothing
                if sim.model.t % (sim.diags.frequency*sim.ΔT) == 0.0
                    write_diags_to_jld2(sim.diags, sim.res_dir, sim.model.t, sim.diags.frequency, sim.model.grid)
                end
            end
            if sim.save_individuals ≠ nothing
                if sim.model.t % (sim.save_individuals*sim.ΔT) == 0.0
                    write_individuals_to_jld2(sim.model.individuals.phytos, sim.res_dir, sim.model.t,
                                                atts=(:x, :y, :z, :Sz))
                end
            end
        end
    end
end

function validate_velocity(vels, g::AbstractGrid{TX, TY, TZ}) where {TX, TY, TZ}
    u_size = (g.Nx, g.Ny, g.Nz)
    v_size = (g.Nx, g.Ny, g.Nz)
    w_size = (g.Nx, g.Ny, g.Nz)
    validation = true

    if isa(TX(), Bounded)
        u_size = (g.Nx+1, g.Ny, g.Nz)
    end

    if isa(TY(), Bounded)
        v_size = (g.Nx, g.Ny+1, g.Nz)
    end

    if isa(TZ(), Bounded)
        w_size = (g.Nx, g.Ny, g.Nz+1)
    end

    if size(vels.u)[1:3] ≠ u_size
        validation = false
        throw(ArgumentError("Dimension mismatch: the size of u must be $(u_size), for $(TX) topology."))
    end

    if size(vels.v)[1:3] ≠ v_size
        validation = false
        throw(ArgumentError("Dimension mismatch: the size of v must be $(v_size), for $(TY) topology."))
    end

    if size(vels.w)[1:3] ≠ w_size
        validation = false
        throw(ArgumentError("Dimension mismatch: the size of w must be $(w_size), for $(TZ) topology."))
    end

    return validation
end

